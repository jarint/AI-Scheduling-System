'''
This class uses objects of the class 'Slot' to build schedules that can be processed by the constraint handling classes
and placed into the tree structure generated by the Tree class. Every object in the schedule must be of the class 'Slot'.

'''

import copy

from Search.Environment import Environment
from Enumerations import ActivityType, Weekday


class Schedule:

    def __init__(self) -> None:
        self.assignments = {slot_id: set() for slot_id in Environment.ALL_SLOT_IDS}
        self.slot_of_each_activity = {} # maps from activity id to slot id to represent which slot each activity is scheduled to
        self.latest_assignment = None # (activity id, slot id)
        self.remaining_games = list(Environment.GAME_IDS) # TODO: needs to initialized to be the entire set of games
        self.remaining_practices = list(Environment.PRACTICE_IDS) # TODO: needs to be initialized to be the entire set of practices
        self.eval = 0
    
    def get_copy(self):
        return copy.deepcopy(self)

    
    def get_activities_in_slot(self, slot_id: "tuple[ActivityType, Weekday, str]") -> "set[str]":
        return self.assignments[slot_id]

    def getEval(self):
        return self.eval

    def assign_activity(self, activity_id: str, slot_id: "tuple[ActivityType, Weekday, str]"):
        """
        Assumes that the type of activity associated with 'activity_id' is of the same type as 'slot_id'
        """
        activity_type = Environment.ACTIVITY_ID_TO_OBJ[activity_id].ACTIVITY_TYPE

        if activity_type == ActivityType.GAME:
            self.assign_game(activity_id, slot_id)
        elif activity_type == ActivityType.PRACTICE:
            self.assign_practice(activity_id, slot_id)
        else:
            raise(RuntimeError("Invalid activity type of slot ID in 'assign_activity()' method"))


    def assign_game(self, game_id: str, slot_id: "tuple[ActivityType, Weekday, str]"):
        self.assignments[slot_id].add(game_id)
        self.slot_of_each_activity[game_id] = slot_id
        self.latest_assignment = (game_id, slot_id)
        self.remaining_games.remove(game_id) # if this line causes errors, maybe try a reassignment
        # print("Games left: " + str(self.remaining_games))


    def assign_practice(self, practice_id: str, slot_id: "tuple[ActivityType, Weekday, str]"):
        # print("Practice: " + practice_id)
        # print("Slot: " + str(slot_id))
        # print("Remaining games: " + str(self.remaining_games))
        # print("Remaining practices: " + str(self.remaining_practices))
        # print()
        self.assignments[slot_id].add(practice_id)
        self.slot_of_each_activity[practice_id] = slot_id
        self.latest_assignment = (practice_id, slot_id)
        self.remaining_practices.remove(practice_id) # if this line causes errors, maybe try a reassignment
        # print("Practices left: " + str(self.remaining_practices))